<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
        "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <!-- UTF-8编码 -->
    <property name="charset" value="UTF-8"/>
    <!-- 这条注释使得所有的错误都变成warning,不影响构建结果 -->
    <property name="severity" value="warning"/>
    <!-- 检查尺寸违规  -->
    <!-- 检查文件的长度（行） default max = 2000 -->
    <module name="FileLength">
        <property name="max" value="2500"/>
    </module>

    <!-- 检查属性文件是否包含相同的key. -->
    <!-- 检查**.properties配置文件 是否有相同的key -->
    <module name="Translation">
    </module>


    <module name="TreeWalker">
        <module name="EmptyLineSeparator">
            <property name="tokens"
                      value="CLASS_DEF,CTOR_DEF,ENUM_DEF,IMPORT,INSTANCE_INIT,INTERFACE_DEF,METHOD_DEF,PACKAGE_DEF,STATIC_INIT,VARIABLE_DEF"/>
        </module>
        <!-- 检查imports    -->
        <!-- 必须导入类的完整路径，即不能使用*导入所需的类 -->
        <module name="AvoidStarImport"/>
        <!-- 检查是否从非法的包中导入了类 illegalPkgs: 定义非法的包名称-->
        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
        <!-- 检查是否导入了不必显示导入的类-->
        <module name="RedundantImport"/>
        <!-- 检查是否导入的包没有使用-->
        <module name="UnusedImports"/>
        <!-- 检查空格 -->
        <module name="EmptyForIteratorPad"/>
        <module name="MethodParamPad"/>
        <module name="NoWhitespaceAfter"/>
        <module name="NoWhitespaceBefore"/>
        <module name="OperatorWrap"/>
        <module name="ParenPad"/>
        <module name="TypecastParenPad"/>
        <module name="WhitespaceAfter"/>
        <module name="WhitespaceAround"/>


        <!-- 检查类和接口的javadoc 默认不检查author 和version tags
          authorFormat: 检查author标签的格式
                versionFormat: 检查version标签的格式
                scope: 可以检查的类的范围，例如：public只能检查public修饰的类，private可以检查所有的类
                excludeScope: 不能检查的类的范围，例如：public，public的类将不被检查，但访问权限小于public的类仍然会检查，其他的权限以此类推
                tokens: 该属性适用的类型，例如：CLASS_DEF,INTERFACE_DEF -->
        <module name="JavadocType">
            <property name="authorFormat" value="\S"/>
            <property name="scope" value="protected"/>
            <property name="tokens" value="CLASS_DEF,INTERFACE_DEF"/>
        </module>

        <!-- 检查方法的javadoc的注释
                scope: 可以检查的方法的范围，例如：public只能检查public修饰的方法，private可以检查所有的方法
                allowMissingParamTags: 是否忽略对参数注释的检查
                allowMissingThrowsTags: 是否忽略对throws注释的检查
                allowMissingReturnTag: 是否忽略对return注释的检查 -->
        <module name="JavadocMethod">
            <property name="scope" value="private"/>
            <property name="allowMissingParamTags" value="false"/>
            <property name="allowMissingThrowsTags" value="false"/>
            <property name="allowMissingReturnTag" value="false"/>
            <property name="allowUndeclaredRTE" value="true"/>
            <property name="allowThrowsTagsForSubclasses" value="true"/>
            <!--允许get set 方法没有注释-->
            <property name="allowMissingPropertyJavadoc" value="true"/>
            <property name="tokens" value="METHOD_DEF"/>
        </module>

        <!-- 检查类变量的注释
                scope: 检查变量的范围，例如：public只能检查public修饰的变量，private可以检查所有的变量 -->
        <module name="JavadocVariable">
            <property name="scope" value="private"/>
        </module>

        <!-- option: 定义左大括号'{'显示位置，eol在同一行显示，nl在下一行显示
          maxLineLength: 大括号'{'所在行行最多容纳的字符数
          tokens: 该属性适用的类型，例：CLASS_DEF,INTERFACE_DEF,METHOD_DEF,CTOR_DEF -->
        <module name="LeftCurly">
            <property name="option" value="eol"/>
            <property name="tokens"
                      value="ANNOTATION_DEF,LITERAL_CATCH,CLASS_DEF,CTOR_DEF,LITERAL_DO,LITERAL_ELSE,ENUM_CONSTANT_DEF,ENUM_DEF,LITERAL_FINALLY,LITERAL_FOR,LITERAL_IF,INTERFACE_DEF,METHOD_DEF,LITERAL_SWITCH,LITERAL_SYNCHRONIZED,LITERAL_TRY,LITERAL_WHILE"/>
        </module>

        <!-- 检查右花括号（'}'）的位置为else，try和catch标记。要使用属性选项指定要验证的策略.
          option: 右大括号是否单独一行显示
          tokens: 定义检查的类型  -->
        <module name="RightCurly">
            <property name="option" value="alone"/>
            <property name="tokens" value="LITERAL_CATCH,LITERAL_ELSE,LITERAL_FINALLY,LITERAL_IF,LITERAL_TRY"/>
        </module>

        <!-- 检查是否应该使用括号的地方没有加括号
          tokens: 定义检查的类型 -->
        <module name="NeedBraces">
            <property name="tokens" value="LITERAL_DO,LITERAL_ELSE,LITERAL_FOR,LITERAL_IF,LITERAL_WHILE"/>
        </module>


        <!-- 检查在重写了equals方法后是否重写了hashCode方法 -->
        <module name="EqualsHashCode"/>

        <!--  检查首选工厂方法的非法实例化。基本原理：根据项目的不同，对于某些类，最好通过工厂方法创建实例，而不是调用构造函数。
          一个简单的例子是java.lang.Boolean类。为了节省内存和CPU周期，最好使用预定义的常量TRUE和FALSE。应该通过调用Boolean.valueOf（）来替换构造函数调用。一些性能极为敏感的项目可能还需要对其他类使用工厂方法，以强制使用数字高速缓存或对象池。 -->
        <module name="IllegalInstantiation">
            <property name="classes" value="java.lang.Boolean"/>
        </module>

        <!-- 包名 -->
        <module name="PackageName">
            <property name="format" value="^[a-z]+(\.[a-z][a-z0-50]*)*$"/>
        </module>
        <!-- 类和接口 -->
        <module name="TypeName">
            <property name="format" value="(^[A-Z][a-zA-Z0-9]{0,50}$)"/>
        </module>
        <!-- 方法 -->
        <module name="MethodName">
            <property name="format" value="(^[a-z][a-zA-Z0-9]{0,50}$)"/>
        </module>
        <!-- 本地final变量,包括catch参数 -->
        <module name="LocalFinalVariableName"/>
        <!-- 常量(静态,final字段) -->
        <module name="ConstantName">
            <property name="format" value="(^[A-Z0-9_]{0,50}$)"/>
        </module>
        <!-- 静态,非final字段 -->
        <module name="StaticVariableName">
            <property name="format" value="(^[A-Z0-9_]{0,50}$)"/>
        </module>
        <!-- 非静态字段 -->
        <module name="MemberName">
            <property name="format" value="(^[a-z][a-z0-9][a-zA-Z0-9]{0,50}$)"/>
        </module>
        <!-- 本地非final变量,包括catch参数 -->
        <module name="LocalVariableName"/>
        <!-- 参数 -->
        <module name="ParameterName">
            <property name="format" value="(^[a-z][a-zA-Z0-9_]{0,50}$)"/>
        </module>
        <!-- 代码缩进   -->
        <module name="Indentation"/>

        <!-- 检查boolean值是否冗余的地方 -->
        <module name="SimplifyBooleanExpression"/>
        <!--  检查是否存在过度复杂的boolean返回值 -->
        <module name="SimplifyBooleanReturn"/>

        <!-- 只有私有构造器的类必须声明为final -->
        <module name="FinalClass"/>

        <!-- 确保Utils类（只提供static方法和属性的类）没有public构造器。-->
        <module name="HideUtilityClassConstructor"/>

        <!-- 检查class成员属性可见性。只有static final 修饰的成员是可以public的。其他的成员属性必需是private的，除非属性protectedAllowed或者packageAllowed设置了true.强制封装 -->
        <module name="VisibilityModifier"/>

        <!-- 每一行只能定义一个变量 -->
        <module name="MultipleVariableDeclarations">
        </module>

        <!-- 、检查再定义数组时，采用java风格还是c风格，例如：int[] num是java风格，int num[]是c风格。默认是java风格 -->
        <module name="ArrayTypeStyle">
        </module>

        <!-- 魔术数字的配置。默认情况下，-1,0,1和2不被视为幻数 -->
        <module name="MagicNumber">
            <property name="ignoreHashCodeMethod" value="true"/>
            <property name="ignoreAnnotation" value="true"/>
            <property name="ignoreFieldDeclaration" value="true"/>
            <property name="constantWaiverParentToken"
                      value="DIV,MINUS,UNARY_MINUS,STAR,PLUS,UNARY_PLUS,ASSIGN,ARRAY_INIT,EXPR,ELIST,METHOD_CALL,LITERAL_NEW,TYPECAST"/>
        </module>

        <module name="AvoidInlineConditionals"/>
        <module name="EmptyStatement"/>
        <module name="EqualsHashCode"/>
        <module name="HiddenField">
            <property name="tokens" value="VARIABLE_DEF"/>
            <property name="ignoreConstructorParameter" value="true"/>
            <property name="ignoreSetter" value="true"/>
            <property name="setterCanReturnItsClass" value="true"/>
            <property name="ignoreAbstractMethods" value="true"/>
        </module>
        <module name="IllegalInstantiation"/>
        <module name="InnerAssignment"/>

        <!-- 检查是否存在TODO（待处理） TODO是javaIDE自动生成的。一般代码写完后要去掉 -->
        <module name="TodoComment"/>

        <!--  检查是否在long类型是否定义了大写的L.字母小写l和数字1（一）很相似 -->
        <module name="UpperEll"/>

        <!--  检查switch语句是否有default从句 -->
        <module name="MissingSwitchDefault"/>

        <!--检查switch中case后是否加入了跳出语句，例如：return、break、throw、continue -->
        <module name="FallThrough"/>
        <!-- 检查方法或构造函数的参数数量。最大默认值 7个. -->
        <module name="ParameterNumber">
            <property name="max" value="5"/>
        </module>
        <!-- 每行字符数 -->
        <module name="LineLength">
            <property name="max" value="300"/>
        </module>

        <!-- 检查长方法和构造函数。最大默认值 150行. max=300 设置长度300 -->
        <module name="MethodLength">
            <property name="max" value="300"/>
        </module>

        <!-- ModifierOrder 检查修饰符的顺序
             默认是 public,protected,private,abstract,static,final,transient,volatile,synchronized,native
        -->
        <module name="ModifierOrder">
        </module>

        <!-- 检查是否有多余的修饰符，例如：接口中的方法不必使用public、abstract修饰  -->
        <module name="RedundantModifier">
        </module>

        <!--- 字符串比较必须使用 equals() -->
        <module name="StringLiteralEquality">
        </module>

        <!-- if-else嵌套语句个数 最多4层 -->
        <module name="NestedIfDepth">
            <property name="max" value="3"/>
        </module>

        <!-- try-catch 嵌套语句个数 最多2层 -->
        <module name="NestedTryDepth">
            <property name="max" value="2"/>
        </module>

        <!-- 返回个数 -->
        <module name="ReturnCount">
            <property name="max" value="5"/>
            <property name="format" value="^$"/>
        </module>

    </module>


</module>
